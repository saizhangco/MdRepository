**方腾飞 魏鹏 程晓明**
# 1 并发编程的挑战
## 1.1 上下文切换
## 1.2 死锁
## 1.3 资源限制的挑战
# 2 Java并发机制的底层实现原理
## 2.1 volatile的应用
## 2.2 synchronized的实现原理与应用
## 2.3 原子操作的实现原理
# 3 Java内存模型
## 3.1 Java内存模型的基础
## 3.2 重排序
## 3.3 顺序一致性
## 3.4 volatile的内存语义
## 3.5 锁的内存语义
## 3.6 final域的内存语义
## 3.7 happens-before
## 3.8 双重检查锁定与延迟初始化
## 3.9 Java内存模型综述
# 4 Java并发编程基础
## 4.1 线程简介
## 4.2 启动和终止线程
## 4.3 线程间通信
## 4.4 线程应用实例
# 5 Java中的锁
## 5.1 Lock接口
## 5.2 队列同步器
## 5.3 重入锁
## 5.4 读写锁
## 5.5 LockSupport工具
## 5.6 Condition接口
# 6 Java并发容器和框架
## 6.1 ConcurrentHashMap的实现原理
## 6.2 ConcurrentLinkedQueue
## 6.3 Java中的阻塞
## 6.4 Fork/Join框架
# 7 Java中的13个原子操作类
## 7.1 原子更新基本类
## 7.2 原子更新数组
## 7.3 原子更新引用类型
## 7.4 原子更新字段类
# 8 Java中的并发工具类
## 8.1 等待多线程完成的CountDownLatch
## 8.2 同步屏障CyclicBarrier
## 8.3 控制并发线程数的Semaphore
## 8.4 线程间交换数据的Exchanger
# 9 Java中的线程池
## 9.1 线程池的实现原理
## 9.2 线程池的使用
# 10 Executor框架
## 10.1 Executor框架简介
## 10.2 ThreadPoolExecutor详解
## 10.3 ScheduleThreadPoolExecutor详解
## 10.4 FutureTask详解
# 11 Java并发编程实践
## 11.1 生产者和消费者模式
**什么是生产者消费者模式？**
> 生产者和消费者模式是通过一个容器来解决生产者和消费的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

>阻塞队列就是用来给生产者和消费者解耦的。

>大多数设计模式，都会找一个第三者出来进行解耦，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。

**多生产者和多消费者场景**
## 11.2 线上问题定位
>很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以线上问题定位需要**看日志、系统状态、dump线程**。

1. 在Linux命令行下使用TOP命令查看每个进程的情况。
2. 再使用top的交互命令数字1查看每个CPU的性能数据。
3. 使用top的交互命令H查看每个线程的性能信息。

**分析**

1. 某个线程CPU利用率一直100%，则说明是这个线程有可能有死循环，那么请记住这个PID。
2. 某个线程一直在TOP 10的位置，这说明这个线程可能有性能问题。
3. CPU利用率高的几个线程在不停变化，说明并不是由一个线程导致CPU偏高。

`sudo /opt/java/bin/jstat -gcutil 31177 1000 5` 
## 11.3 性能测试
## 11.4 异步任务池